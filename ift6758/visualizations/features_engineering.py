import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd

#from simple_visualizations import shots_efficiency_by_distance

sns.set()


def shots_and_goals_by_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the shot and goals according to the distance to goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent distances, goals and non-goals
    """

    plt.close("all")

    Tirs = []
    Buts = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["distanceToGoal"])

    # Change float values into int to deal with constant distances
    df["distanceToGoal"] = (df["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    distinct_distances = np.unique(df["distanceToGoal"])

    for d in distinct_distances :
        # Filter dataframe according to distance
        df2 = df[df["distanceToGoal"] == d]
        Tirs.append(len(df2[df2["event"] == "Shot"]))
        Buts.append(len(df2[df2["event"] == "Goal"]))

    # Plot total number of shots and goals for every distances
    width = group_feet

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_distances, Tirs, width=width, color='b', label='Non-Buts')
        plt.bar(distinct_distances, Buts, width=0.5 * width, color='r', label='Buts')
        # Add title and legends 
        plt.title("Nombre de buts et de non-buts en fonction de la distance aux cages, de la saison 2015-2016 à 2018-2019")
        plt.xlabel("Distance en pieds")
        plt.ylabel("Nombre de tirs")
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + "shots_and_goals_by_distance.png")
    if save or plot:
        plt.close()
    return (distinct_distances, Tirs, Buts)


def shots_and_goals_by_angles(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_deg: int = 5) -> tuple:
    """
    Make graphics of the shot and goals according to the angle with goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_deg : Integer to regroup angles. For exemple if group_deg = 5, shots will be grouped 5 degrees by 5 degrees

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent angles, goals and non-goals
    """

    plt.close("all")

    Tirs = []
    Buts = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["angleWithGoal"])

    # Change float values into int to deal with constant distances
    df["angleWithGoal"] = (df["angleWithGoal"].astype("int64")).apply(
        lambda x: group_deg * (x // group_deg))  # Regroup shot by group_deg distances
    distinct_angles = np.unique(df["angleWithGoal"])

    for d in distinct_angles :
        # Filter dataframe according to angles
        df2 = df[df["angleWithGoal"] == d]
        Tirs.append(len(df2[df2["event"] == "Shot"]))
        Buts.append(len(df2[df2["event"] == "Goal"]))

    # Plot total number of shots and goals for every angles
    width = group_deg

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_angles, Tirs, width=width, color='b', label='Non-Buts')
        plt.bar(distinct_angles, Buts, width=0.5 * width, color='r', label='Buts')
        # Add title and legends 
        plt.title("Nombre de buts et de non-buts en fonction de l'angle avec les cages, de la saison 2015-2016 à 2018-2019")
        plt.xlabel("Angle en degrés")
        plt.ylabel("Nombre de tirs")
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + "shots_and_goals_by_angles.png")
    if save or plot:
        plt.close()
    return (distinct_angles, Tirs, Buts)

def shots_by_angles_and_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                          path_to_save: str = "./", group_feet: int = 6, group_deg: int = 5) -> tuple:
    '''
    Make graphics of the shot according to the angle and the distance to goal. You can also choose to either plot the figure or not, and to save it. 

    Args : 
        - plays_df : DataFrame obtained by 'play_to_frame' function
        - plot : choose to plot the figure or not
        - path_to_save : path where to save the figure
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet
        - group_deg : Integer to regroup angles. For exemple if group_deg = 5, shots will be grouped 5 degrees by 5 degrees

    Return :
        Return the table of the number of shot according to the distance and the angle with goal
    '''

    plt.close("all")

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["distanceToGoal"])
    # Remove row with nan data in column "distanceToGoal"
    df = df.dropna(subset=["angleWithGoal"])

    data = df.copy()
    data["distanceToGoal"] = (data["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    data["angleWithGoal"] = (data["angleWithGoal"].astype("int64")).apply(
        lambda x: group_deg * (x // group_deg))  # Regroup shot by group_deg distances
    data = data.groupby(["distanceToGoal", "angleWithGoal"]).count().reset_index()
    bins_size = len(np.unique(data["distanceToGoal"]))

    if save or plot:
        # Create figure
        p = sns.jointplot(data=df, x="distanceToGoal", y="angleWithGoal", kind="hist", height = 8, marginal_kws=dict(bins=bins_size), joint_kws=dict(bins=bins_size))
        # Add title and legends 
        p.fig.suptitle("Nombre de tirs en fonction de l'angle et de la distance avec les cages,\n de la saison 2015-2016 à 2018-2019")
        p.fig.subplots_adjust(top=0.92) # Reduce plot to make room 
        plt.xlabel("Distance en pieds")
        plt.ylabel("Angle en degrés")

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        p.fig.savefig(path_to_save + "shots_by_angles_and_distance.png")
    if save or plot:
        plt.close()
    return data.pivot("distanceToGoal", "angleWithGoal", values = "event")

def goal_ratio_by_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the goal ratio according to the distance to goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent distances and goals ratio
    """

    ratio = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["distanceToGoal"])

    # Change float values into int to deal with constant distances
    df["distanceToGoal"] = (df["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by 10 feet distances
    distinct_distances = np.unique(df["distanceToGoal"])

    for d in distinct_distances:
        # Filter dataframe according to distance
        df2 = df[df["distanceToGoal"] == d]

        # Add ratio of goals in ratio list
        ratio.append(len(df2[df2["event"] == "Goal"]) / len(df2) * 100)
    ratio = np.array(ratio)

    if save or plot:
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_distances, ratio, width=group_feet)
        plt.title(f"Pourcentage de tirs réussis en fonction de la distance, de la saison 2015-2016 à 2018-2019")
        plt.xlabel("Distance en pieds")
        plt.ylabel("Ratio de tirs réussis")

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + f"goal_ratio_by_distance.png")
    if save or plot:
        plt.close()
    return (distinct_distances, ratio)


def goal_ratio_by_angles(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_deg: int = 5) -> tuple:
    """
    Make graphics of the goal ratio according to the angle with goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_deg : Integer to regroup angles. For exemple if group_deg = 5, shots will be grouped 5 degrees by 5 degrees

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent angles and goal ratio
    """

    ratio = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["angleWithGoal"])

    # Change float values into int to deal with constant distances
    df["angleWithGoal"] = (df["angleWithGoal"].astype("int64")).apply(
        lambda x: group_deg * (x // group_deg))  # Regroup shot by group_deg distances
    distinct_angles = np.unique(df["angleWithGoal"])

    for d in distinct_angles:
        # Filter dataframe according to distance
        df2 = df[df["angleWithGoal"] == d]

        # Add ratio of goals in ratio list
        ratio.append(len(df2[df2["event"] == "Goal"]) / len(df2) * 100)
    ratio = np.array(ratio)

    if save or plot:
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_angles, ratio, width=group_deg)
        plt.title(f"Pourcentage de tirs réussis en fonction de l'angle avec les cages, de la saison 2015-2016 à 2018-2019")
        plt.xlabel("Angle en degrés")
        plt.ylabel("Ratio de tirs réussis")

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + f"goal_ratio_by_angles.png")
    if save or plot:
        plt.close()
    return (distinct_angles, ratio)


def empty_goal_by_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the goals according to the distance when the goal is empty or not. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent distances and the number of goals when the goal is empty or not
    """

    plt.close("all")

    Buts_vide = []
    Buts_non_vide = []

    # Replace nan values with 0
    plays_df["emptyNet"] = plays_df["emptyNet"].fillna(0)

    df_empty_goal = plays_df[plays_df["emptyNet"] == 1]
    df_not_empty_goal = plays_df[plays_df["emptyNet"] == 0]

    # Remove row with nan data in column "distanceToGoal"
    df_empty_goal = df_empty_goal.dropna(subset=["distanceToGoal"])
    df_not_empty_goal = df_not_empty_goal.dropna(subset=["distanceToGoal"])

    # Change float values into int to deal with constant distances
    df_empty_goal["distanceToGoal"] = (df_empty_goal["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    distinct_distances_empty = np.unique(df_empty_goal["distanceToGoal"])

    df_not_empty_goal["distanceToGoal"] = (df_not_empty_goal["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    distinct_distances_not_empty = np.unique(df_not_empty_goal["distanceToGoal"])

    for d in distinct_distances_empty :
        # Filter dataframe according to distance
        df2_empty = df_empty_goal[df_empty_goal["distanceToGoal"] == d]
        Buts_vide.append(len(df2_empty[df2_empty["event"] == "Goal"]))

    for d in distinct_distances_not_empty :
        # Filter dataframe according to distance
        df2_not_empty = df_not_empty_goal[df_not_empty_goal["distanceToGoal"] == d]
        Buts_non_vide.append(len(df2_not_empty[df2_not_empty["event"] == "Goal"]))

    # Plot total number of shots and goals for every distances
    width = group_feet

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.subplot(1, 2, 1)
        plt.bar(distinct_distances_empty, Buts_vide, width=width, color='b', label='Cage vide')
        plt.xlabel("Distance en pieds")
        plt.ylabel("Nombre de buts")
        plt.legend()
        plt.subplot(1, 2, 2)
        plt.bar(distinct_distances_not_empty, Buts_non_vide, width=width, color='r', label='Cage protégée')
        # Add title and legends 
        plt.suptitle("Nombre de buts en fonction de la distance avec des cages vide et protégée, de la saison 2015-2016 à 2018-2019")
        plt.xlabel("Distance en pieds")
        plt.ylabel("Nombre de buts")
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + "empty_goal_by_distance.png")
    if save or plot:
        plt.close()
    return (distinct_distances_empty, Buts_vide, distinct_distances_not_empty, Buts_non_vide)


