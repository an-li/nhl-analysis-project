import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd

sns.set()

def shots_efficiency_by_type(plays_df: pd.DataFrame, season: int, save: bool = True, plot: bool = True,
                             path_to_save: str = "./") -> tuple:
    '''
	Make graphics of the shot efficiency according to the type of shot for a season passed in parameter. You can also choose to either plot the figure or not, and to save it. 

    Args : 
        - plays_df : DataFrame obtained by 'play_by_play' function
        - season : season of your choice (between 2016 and 2021) -> example : 20162017
        - save : Boolean to choose to save the figure
        - plot : choose to plot the figure or not
        - path_to_save : path where to save the figure

    Return :
    	Return a tuple of x coordinate and y coordinate which represent types, shots and goals
    '''

    # Filter dataframe according to season 
    df = plays_df[plays_df["season"] == season]

    # Drop 'nan' values in 'shotType'
    df = df.dropna(subset=["shotType"])

    # Obtain a list of shots types 
    distinct_shot = list(set(df["shotType"]))
    shots = []
    goals = []

    # Count number of shots and goals for every type 
    for shot in distinct_shot:
        df2 = df[df["shotType"] == shot]
        shots.append(len(df2))
        goals.append(len(df2[df2["event"] == "Goal"]))

    # Plot total number of shots and goals for every type of shot 
    X_axis = np.arange(len(distinct_shot))
    width = len(X_axis) / 10

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.bar(X_axis, shots, width=width, color='b', label='Shots')
        plt.bar(X_axis, goals, width=0.5 * width, color='r', label='Goals')

    for i in X_axis:
        # Add % of goals for every type of shot on the bar 
        plt.text(i - 2 / 5 * width, shots[i] + max(shots) / 100, str(round(goals[i] / shots[i] * 100, 2)) + "% goal")

    if save or plot:
        # Add title and legends 
        plt.title("Shots and goal according to shot type")
        plt.xticks(X_axis, distinct_shot)
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + f"shot_efficiency_according_to_type{str(season)[0:4]}_{str(season)[4:8]}.png")
    if save or plot:
        plt.close()
    return (distinct_shot, shots, goals)


def shots_efficiency_by_distance(plays_df: pd.DataFrame, seasons_list: list, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the shot efficiency according to the distance to goal for all seasons passed in parameters. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - seasons_list : list of int for the seasons we want to study. For example, season 2019-2020 is represanted by int 20192020
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate according to the chosen seasons
    """

    plt.close("all")
    ratio = []
    distinct_distances = []
    for season in seasons_list:
        # Define empty list of ratio of goals 
        ratio_for_season = []

        # Filter dataframe according to the season
        df = plays_df[plays_df["season"] == season]

        # Remove row with nan data in column "distanceToGoal"
        df = df.dropna(subset=["distanceToGoal"])

        # Change float values into int to deal with constant distances
        df["distanceToGoal"] = (df["distanceToGoal"].astype("int64")).apply(
            lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by 10 feet distances
        distinct_distances_for_season = np.unique(df["distanceToGoal"])

        for d in distinct_distances_for_season:
            # Filter dataframe according to distance
            df2 = df[df["distanceToGoal"] == d]

            # Add ratio of goals in ratio list
            ratio_for_season.append(len(df2[df2["event"] == "Goal"]) / len(df2) * 100)
        ratio_for_season = np.array(ratio_for_season)

        distinct_distances.append(distinct_distances_for_season)
        ratio.append(ratio_for_season)

        if save or plot:
            fig = plt.figure(figsize=[14, 8])
            plt.bar(distinct_distances_for_season, ratio_for_season, width=group_feet)
            plt.title(f"Percentage of scoring shots according to distance for season "
                      f"{str(season)[0:4]}-{str(season)[4:8]}")
            plt.xlabel("Distance (ft)")
            plt.ylabel("Percentage of scoring shots")

        # Plot and save the figure (if True)
        if plot:
            plt.show()
        if save:
            fig.savefig(path_to_save + f"shot_efficiency_according_to_distance{str(season)[0:4]}_{str(season)[4:8]}.png")
        if save or plot:
            plt.close()
    return (distinct_distances, ratio)


def shots_efficiency_by_type_and_distance(plays_df: pd.DataFrame, season: int, save: bool = True, plot: bool = True,
                                          path_to_save: str = "./", group_feet: int = 6) -> tuple:
    '''
    Make graphics of the shot efficiency according to the type of shot and the distance to goal, for a season passed in parameter. You can also choose to either plot the figure or not, and to save it. 

    Args : 
        - plays_df : DataFrame obtained by 'play_to_frame' function
        - season : season of your choice (between 2016 and 2021) -> example : 20162017 
        - plot : choose to plot the figure or not
        - path_to_save : path where to save the figure
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Return :
        Return a tuple of x coordinate and y coordinate which represent types, shots and goals
    '''

    plt.close("all")
    if save or plot:
        # Create subplot with 7 graphics
        fig, ax = plt.subplots(4, 2, figsize=(15, 8))
        fig.tight_layout(pad=5.0)
        fig.delaxes(ax[3][1])

    # Filter df by season and remove nan values
    df = plays_df[plays_df["season"] == season]
    df = df.dropna(subset=["distanceToGoal", "shotType"])

    # Obtain a list of shots types
    distinct_shot = list(set(df["shotType"]))

    count = 0
    X = []
    Y = []

    for shot in distinct_shot:
        # Filter by type of shot
        df2 = df[df["shotType"] == shot]

        # Use function to have x coordinate and y coordinate for distances and efficiency
        t = shots_efficiency_by_distance(df2, [season], save=False, plot=False, group_feet=group_feet)
        x = t[0][0]
        y = t[1][0]
        X.append(x)
        Y.append(y)

        if save or plot:
            # Create graphics
            ax[count // 2, count % 2].bar(x, y, label=shot, width=group_feet)
            ax[count // 2, count % 2].title.set_text(f"Percentage of scoring shots according to shot type and distance "
                                                     f"for season {str(season)[0:4]}-{str(season)[4:8]}")
            ax[count // 2, count % 2].set_xlabel("Distance (ft)")
            ax[count // 2, count % 2].set_ylabel("Percentage of scoring shots")
            ax[count // 2, count % 2].legend()
        count += 1

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + f"shot_efficiency_according_to_type_and_distance{str(season)[0:4]}_{str(season)[4:8]}.png")
    if save or plot:
        plt.close()
    return (X, Y)
