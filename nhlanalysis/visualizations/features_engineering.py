import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd

#from simple_visualizations import shots_efficiency_by_distance

sns.set()


def shots_and_goals_by_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the shot and goals according to the distance to goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent distances, goals and non-goals
    """

    plt.close("all")

    shots = []
    goals = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["distanceToGoal"])

    # Change float values into int to deal with constant distances
    df["distanceToGoal"] = (df["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    distinct_distances = np.unique(df["distanceToGoal"])

    for d in distinct_distances :
        # Filter dataframe according to distance
        df2 = df[df["distanceToGoal"] == d]
        shots.append(len(df2[df2["event"] == "Shot"]))
        goals.append(len(df2[df2["event"] == "Goal"]))

    # Plot total number of shots and goals for every distances
    width = group_feet

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_distances, shots, width=width, color='b', label='Shots')
        plt.bar(distinct_distances, goals, width=0.5 * width, color='r', label='Goals')
        # Add title and legends 
        plt.title("Number of shots and goals according to distance to goal for seasons 2015-2016 to 2018-2019")
        plt.xlabel("Distance to goal (ft)")
        plt.ylabel("Number of shots")
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + "shots_and_goals_by_distance.png")
    if save or plot:
        plt.close()
    return (distinct_distances, shots, goals)


def shots_and_goals_by_angles(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_deg: int = 5) -> tuple:
    """
    Make graphics of the shot and goals according to the angle with goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_deg : Integer to regroup angles. For exemple if group_deg = 5, shots will be grouped 5 degrees by 5 degrees

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent angles, goals and non-goals
    """

    plt.close("all")

    shots = []
    goals = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["angleWithGoal"])

    # Change float values into int to deal with constant distances
    df["angleWithGoal"] = (df["angleWithGoal"].astype("int64")).apply(
        lambda x: group_deg * (x // group_deg))  # Regroup shot by group_deg distances
    distinct_angles = np.unique(df["angleWithGoal"])

    for d in distinct_angles :
        # Filter dataframe according to angles
        df2 = df[df["angleWithGoal"] == d]
        shots.append(len(df2[df2["event"] == "Shot"]))
        goals.append(len(df2[df2["event"] == "Goal"]))

    # Plot total number of shots and goals for every angles
    width = group_deg

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_angles, shots, width=width, color='b', label='Shots')
        plt.bar(distinct_angles, goals, width=0.5 * width, color='r', label='Goals')
        # Add title and legends 
        plt.title("Number of shots and goals according to angle with goal for seasons 2015-2016 to 2018-2019")
        plt.xlabel("Angle with goal (°)")
        plt.ylabel("Number of shots")
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + "shots_and_goals_by_angles.png")
    if save or plot:
        plt.close()
    return (distinct_angles, shots, goals)

def shots_by_angles_and_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                          path_to_save: str = "./", group_feet: int = 6, group_deg: int = 5) -> tuple:
    '''
    Make graphics of the shot according to the angle and the distance to goal. You can also choose to either plot the figure or not, and to save it. 

    Args : 
        - plays_df : DataFrame obtained by 'play_to_frame' function
        - plot : choose to plot the figure or not
        - path_to_save : path where to save the figure
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet
        - group_deg : Integer to regroup angles. For exemple if group_deg = 5, shots will be grouped 5 degrees by 5 degrees

    Return :
        Return the table of the number of shot according to the distance and the angle with goal
    '''

    plt.close("all")

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["distanceToGoal"])
    # Remove row with nan data in column "distanceToGoal"
    df = df.dropna(subset=["angleWithGoal"])

    data = df.copy()
    data["distanceToGoal"] = (data["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    data["angleWithGoal"] = (data["angleWithGoal"].astype("int64")).apply(
        lambda x: group_deg * (x // group_deg))  # Regroup shot by group_deg distances
    data = data.groupby(["distanceToGoal", "angleWithGoal"]).count().reset_index()
    bins_size = len(np.unique(data["distanceToGoal"]))

    if save or plot:
        # Create figure
        p = sns.jointplot(data=df, x="distanceToGoal", y="angleWithGoal", kind="hist", height = 8, marginal_kws=dict(bins=bins_size), joint_kws=dict(bins=bins_size))
        # Add title and legends 
        p.fig.suptitle("Number of shots and goals according to distance and angle for seasons 2015-2016 to 2018-2019")
        p.fig.subplots_adjust(top=0.92) # Reduce plot to make room 
        plt.xlabel("Distance to goal (ft)")
        plt.ylabel("Angle with goal (°)")

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        p.fig.savefig(path_to_save + "shots_by_angles_and_distance.png")
    if save or plot:
        plt.close()
    return data.pivot("distanceToGoal", "angleWithGoal", values = "event")

def goal_ratio_by_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the goal ratio according to the distance to goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent distances and goals ratio
    """

    ratio = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["distanceToGoal"])

    # Change float values into int to deal with constant distances
    df["distanceToGoal"] = (df["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by 10 feet distances
    distinct_distances = np.unique(df["distanceToGoal"])

    for d in distinct_distances:
        # Filter dataframe according to distance
        df2 = df[df["distanceToGoal"] == d]

        # Add ratio of goals in ratio list
        ratio.append(len(df2[df2["event"] == "Goal"]) / len(df2) * 100)
    ratio = np.array(ratio)

    if save or plot:
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_distances, ratio, width=group_feet)
        plt.title(f"Percentage of scoring shots according to distance to goal 2015-2016 to 2018-2019")
        plt.xlabel("Distance to goal (ft)")
        plt.ylabel("Percentage of scoring shots")

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + f"goal_ratio_by_distance.png")
    if save or plot:
        plt.close()
    return (distinct_distances, ratio)


def goal_ratio_by_angles(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_deg: int = 5) -> tuple:
    """
    Make graphics of the goal ratio according to the angle with goal. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_deg : Integer to regroup angles. For exemple if group_deg = 5, shots will be grouped 5 degrees by 5 degrees

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent angles and goal ratio
    """

    ratio = []

    # Remove row with nan data in column "distanceToGoal"
    df = plays_df.dropna(subset=["angleWithGoal"])

    # Change float values into int to deal with constant distances
    df["angleWithGoal"] = (df["angleWithGoal"].astype("int64")).apply(
        lambda x: group_deg * (x // group_deg))  # Regroup shot by group_deg distances
    distinct_angles = np.unique(df["angleWithGoal"])

    for d in distinct_angles:
        # Filter dataframe according to distance
        df2 = df[df["angleWithGoal"] == d]

        # Add ratio of goals in ratio list
        ratio.append(len(df2[df2["event"] == "Goal"]) / len(df2) * 100)
    ratio = np.array(ratio)

    if save or plot:
        fig = plt.figure(figsize=[14, 8])
        plt.bar(distinct_angles, ratio, width=group_deg)
        plt.title(f"Percentage of scoring shots according to angle with goal 2015-2016 to 2018-2019")
        plt.xlabel("Angle with goal (°)")
        plt.ylabel("Percentage of scoring shots")

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + f"goal_ratio_by_angles.png")
    if save or plot:
        plt.close()
    return (distinct_angles, ratio)


def empty_goal_by_distance(plays_df: pd.DataFrame, save: bool = True, plot: bool = True,
                                 path_to_save: str = "./", group_feet: int = 6) -> tuple:
    """
    Make graphics of the goals according to the distance when the goal is empty or not. You can also choose to either plot the figure or not, and to save it.

    Args:
        - plays_df: Data frame representing plays generated by plays_to_frame
        - plot : Boolean to choose to plot or not
        - save : Boolean to choose to save the figure
        - path_to_save : Path where the figure will be save
        - group_feet : Integer to regroup distances. For exemple if group_feet = 6, shots will be grouped 6 feet by 6 feet

    Returns:
        Return a tuple with list of x coordinate and list of y coordinate which represent distances and the number of goals when the goal is empty or not
    """

    plt.close("all")

    empty_net_goals = []
    non_empty_net_goals = []

    # Replace nan values with 0
    plays_df["emptyNet"] = plays_df["emptyNet"].fillna(0)

    df_empty_goal = plays_df[plays_df["emptyNet"] == 1]
    df_not_empty_goal = plays_df[plays_df["emptyNet"] == 0]

    # Remove row with nan data in column "distanceToGoal"
    df_empty_goal = df_empty_goal.dropna(subset=["distanceToGoal"])
    df_not_empty_goal = df_not_empty_goal.dropna(subset=["distanceToGoal"])

    # Change float values into int to deal with constant distances
    df_empty_goal["distanceToGoal"] = (df_empty_goal["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    distinct_distances_empty = np.unique(df_empty_goal["distanceToGoal"])

    df_not_empty_goal["distanceToGoal"] = (df_not_empty_goal["distanceToGoal"].astype("int64")).apply(
        lambda x: group_feet * ((x - 1) // group_feet) + 1)  # Regroup shot by group_feet distances
    distinct_distances_not_empty = np.unique(df_not_empty_goal["distanceToGoal"])

    for d in distinct_distances_empty :
        # Filter dataframe according to distance
        df2_empty = df_empty_goal[df_empty_goal["distanceToGoal"] == d]
        empty_net_goals.append(len(df2_empty[df2_empty["event"] == "Goal"]))

    for d in distinct_distances_not_empty :
        # Filter dataframe according to distance
        df2_not_empty = df_not_empty_goal[df_not_empty_goal["distanceToGoal"] == d]
        non_empty_net_goals.append(len(df2_not_empty[df2_not_empty["event"] == "Goal"]))

    # Plot total number of shots and goals for every distances
    width = group_feet

    if save or plot:
        # Create figure
        fig = plt.figure(figsize=[14, 8])
        plt.subplot(1, 2, 1)
        plt.bar(distinct_distances_empty, empty_net_goals, width=width, color='b', label='Empty net')
        plt.xlabel("Distance (ft)")
        plt.ylabel("Number of goals")
        plt.legend()
        plt.subplot(1, 2, 2)
        plt.bar(distinct_distances_not_empty, non_empty_net_goals, width=width, color='r', label='Non-empty net')
        # Add title and legends 
        plt.suptitle("Number of goals according to distance, empty and non-empty net, seasons 2015-2016 to 2018-2019")
        plt.xlabel("Distance (ft)")
        plt.ylabel("Number of goals")
        plt.legend()

    # Plot and save the figure (if True)
    if plot:
        plt.show()
    if save:
        fig.savefig(path_to_save + "empty_goal_by_distance.png")
    if save or plot:
        plt.close()
    return (distinct_distances_empty, empty_net_goals, distinct_distances_not_empty, non_empty_net_goals)
